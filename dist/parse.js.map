{"version":3,"sources":["webpack://parse/webpack/universalModuleDefinition","webpack://parse/webpack/bootstrap","webpack://parse/./src/format-expression.js","webpack://parse/./src/parse-ctrl.js","webpack://parse/./src/parse-expression.js","webpack://parse/./src/scope.js","webpack://parse/./src/format-tpl.js","webpack://parse/./src/parse-tpl.js","webpack://parse/./src/index.js","webpack://parse/./src/cjs-entry.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","format","isLit","node","includes","type","isOP","parent","skipBrackets","isSet","snodes","prevNode","brk","children","forEach","idx","push","block","data","open","chain","beforeChain","result","line","declaration","leftSide","leftSideLit","nextNode","val","fn","fnKeyword","argsNode","fnName","fnArgs","isLast","length","lineStart","codeNode","blockStart","argStart","opStart","chainable","skipOutput","op","isOPNoAccessor","space","before","after","isLoc","isSetHere","chainList","formatList","list","isCall","args","locData","slice","map","formatNode","join","formatChain","t","needSpace","close","getLineNumber","str","lines","split","lc","constructor","text","this","start","end","stack","copyStack","last","regexp","flags","RegExp","replace","add","params","ctrl","assign","lastIdx","substring","pop","merge","current","update","keys","key","Array","lineEnd","shift","charAt","substr","startCopy","endCopy","go","moved","next","isEnd","match","startsWith","precedes","endsWith","ParseCtrl","parse","string","quote","matchEscapes","matchQuote","comment","console","log","keyword","keywordsRegex","brackets","{","(","[","dot","comma","colon","semicolon","arrow","number","literal","operation","linebreak","some","_parseCtrl","isInvalid","Scope","concat","bind","new","scope","callArgs","isLocal","setter","chainIdx","error","context","apply","_parseExpression","_interopRequireDefault","_formatExpression","makeHierarchy","cnt","openNode","openNodeIdx","control","tagName","splice","selfClosing","fns","content","default","expression","startTag","matchClose","startComment","endComment","endTag","startAttr","full","prefix","attr","prefixType","startExp","matcher","stringRegex","lastNode","endExp","0","1","2","_parseTpl","_formatTpl","_scope","parseExpression","parseTpl","formatExpression","formatTpl"],"mappings":"CAAA,SAAAA,EAAAC,GACA,iBAAAC,SAAA,iBAAAC,OACAA,OAAAD,QAAAD,IACA,mBAAAG,eAAAC,IACAD,UAAAH,GACA,iBAAAC,QACAA,QAAA,MAAAD,IAEAD,EAAA,MAAAC,IARA,CASCK,OAAA,WACD,mBCTA,IAAAC,KAGA,SAAAC,EAAAC,GAGA,GAAAF,EAAAE,GACA,OAAAF,EAAAE,GAAAP,QAGA,IAAAC,EAAAI,EAAAE,IACAC,EAAAD,EACAE,GAAA,EACAT,YAUA,OANAU,EAAAH,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAQ,GAAA,EAGAR,EAAAD,QA2CA,OAtCAM,EAAAM,EAAAF,EAGAJ,EAAAO,EAAAR,EAGAC,EAAAQ,EAAA,SAAAd,EAAAe,EAAAC,GACAV,EAAAW,EAAAjB,EAAAe,IACAG,OAAAC,eAAAnB,EAAAe,GACAK,cAAA,EACAC,YAAA,EACAC,IAAAN,KAMAV,EAAAiB,EAAA,SAAAvB,GACAkB,OAAAC,eAAAnB,EAAA,cAAiDwB,OAAA,KAIjDlB,EAAAmB,EAAA,SAAAxB,GACA,IAAAe,EAAAf,KAAAyB,WACA,WAA2B,OAAAzB,EAAA,SAC3B,WAAiC,OAAAA,GAEjC,OADAK,EAAAQ,EAAAE,EAAA,IAAAA,GACAA,GAIAV,EAAAW,EAAA,SAAAU,EAAAC,GAAsD,OAAAV,OAAAW,UAAAC,eAAAnB,KAAAgB,EAAAC,IAGtDtB,EAAAyB,EAAA,GAIAzB,IAAA0B,EAAA,0GCnEeC,EAMf,SAASC,EAAOC,GACf,OAAQ,UAAW,SAAU,UAAW,UAAUC,SAASD,EAAKE,MAGjE,SAASC,EAAMH,GACd,OAAQ,YAAa,IAAK,IAAK,IAAK,MAAMC,SAASD,EAAKE,MAwEzD,SAASJ,EAAQM,EAAQF,EAAO,OAAQG,GAAe,EAAOC,GAAQ,GACrE,MACMC,KACN,IACIC,EADAC,GAAM,GAFIL,EAAOM,cAIfC,QAAQ,CAACX,EAAMY,KACpB,IAtEQ,UAAW,YAAa,KAAKX,SAsE1BD,EAtEwCE,OA+E5B,MAAdF,EAAKE,MAA+B,cAAdF,EAAKE,OAAyBO,KAC5DA,EAAMT,EAAKE,UAVM,CACjBK,EAAOM,KAAKb,GACZ,MAAMc,EAAQN,GAA8B,aAAlBA,EAASN,MAA8C,MAAvBM,EAASO,KAAKC,MACpER,GAAqB,MAARC,IAAwB,cAARA,GAAyBN,EAAKH,IAAUG,EAAKK,IAAcM,KAC3FN,EAASC,KAAM,GAEhBA,GAAM,EACND,EAAWR,KASb,IAKIiB,EACAC,EANAC,EAAS,GACO,aAAhBf,EAAOF,MAAwBG,IAClCc,GAAUf,EAAOW,KAAKC,MAEvBR,EAAW,KAGX,IAEIY,EAFAC,GAAc,EACdC,GAAW,EAEXC,GAAc,EAuGlB,OArGAhB,EAAOI,QAAQ,CAACX,EAAMY,KACrB,MAAMY,EAAWjB,EAAOK,EAAM,GAC9B,GAAkB,YAAdZ,EAAKE,MAAwC,aAAlBF,EAAKe,KAAKU,IAAoB,CAC5DzB,EAAK0B,IAAK,EACV1B,EAAK2B,WAAY,EACjB,IAAIC,EAAWrB,EAAOK,EAAM,GACxBgB,GAA8B,YAAlBA,EAAS1B,OACxB0B,EAASF,IAAK,EACdE,EAASC,QAAS,EAClBD,EAAWrB,EAAOK,EAAM,IAErBgB,GAA8B,aAAlBA,EAAS1B,OACxB0B,EAASF,IAAK,EACdE,EAASE,QAAS,QAGXN,GAA8B,OAAlBA,EAAStB,OAC7BF,EAAK0B,IAAK,EACV1B,EAAK8B,QAAS,GAGf,MAAMC,EAASnB,GAAOL,EAAOyB,OAAS,EAEhCC,GADUjC,EAAKE,MACFM,GAAYA,EAASC,KAClCyB,GAAY,OAAQ,QAAQjC,SAASC,GACrCiC,GAAe3B,GAA8B,MAAlBA,EAASN,MAAiB+B,IAAcC,EACnEE,GAAa5B,GAA8B,MAAlBA,EAASN,MAAiB+B,IAAuB,aAAT/B,EACjEmC,EAAU7B,KAAc,YAAa,KAAKP,SAASO,EAASN,OAA2B,YAAlBM,EAASN,QAAwBiC,EACtGG,GAAa,UAAW,SAAU,UAAUrC,SAASD,EAAKE,QAAWmB,GAAeC,GAGtFa,GAAcC,KACjBb,GAAc,GAGXU,IACCb,IACHD,GAAUC,GAEXA,EAAO,GACPC,EAA4B,YAAdrB,EAAKE,OAAuB,QAAS,MAAO,OAAOD,SAASD,EAAKe,KAAKU,MAKjFY,GAAWd,IACdD,GAAW,IAGPD,GAAec,GAAeC,KAClCd,GAAW,GAGRA,GAAYgB,IACff,GAAc,GAIVN,GAAkB,kBAATf,IAA4BoC,GAAchB,IAAae,IAAWF,IAC/EjB,EAAcV,EACdS,MAGD,IAAIsB,GAAa,EACjB,GAAItB,EAAO,CACV,MAAMuB,EAxKT,SAAyBxC,GACxB,OAAQ,YAAa,IAAK,KAAKC,SAASD,EAAKE,MAuKhCuC,CAAezC,GAO1B,GANAuC,GAAa,EACRpC,EAAKH,IACTiB,EAAMJ,KAAKb,GAIRA,EAAKS,KAAO+B,GAAMT,EAAQ,CAC7BQ,GAAcC,IAAOxC,EAAKS,KAAOsB,GACjC,MAAMW,EAAQxB,GAAenB,EAAMmB,GAAe,IAAM,GACxDE,GAAQsB,EA1KZ,SAAsBzB,EAAO0B,EAAQC,EAAOtC,GAAQ,GACnD,IAAIa,EAAS,GACTP,EAAM,EACNiC,EAAQ5B,EAAM,IAAwB,YAAlBA,EAAM,GAAGf,KACjC,MACM4C,EAAaH,GAA0B,cAAhBA,EAAOzC,OAAyB,KAAM,MAAMD,SAAS0C,EAAO5B,KAAKU,MAC7FmB,GAAwB,cAAfA,EAAM1C,OAFM,KAAM,KAAM,IAAK,KAAM,KAAM,KAAM,KAAM,KAAM,MAAO,MAAO,MAAO,OAAQ,KAAM,KAAM,MAEzDD,SAAS2C,EAAM7B,KAAKU,KACzEnB,EAAQA,GAASwC,EACjB,IAAIC,KACJ,MAAMC,EAAa,CAACC,EAAMC,EAAQC,EAAMpB,KACvC,IAAIZ,EAAU,OACd,MAAMiC,EAAUH,EAAK,GAkBrB,OAjBIJ,IACHI,EAAOA,EAAKI,MAAM,IAEnBlC,OAAc8B,EAAKK,IAAIC,GAAYC,KAAK,SACxCrC,GAAU+B,MAAaC,MAAY,QACnChC,GAAU0B,EAAS,QAAU,SACzBA,GACH1B,MAAaoC,EAAWH,MACxBjC,GAAUY,EAAS,OAAS,UAG5BZ,UAAiBiC,EAAQrC,KAAKU,MAC1BM,IACHZ,YAAmBiC,EAAQrC,KAAKU,YAGlCN,GAAUY,EAAS,QAAU,KAKxBwB,EAAalF,GAAKA,EAAE0C,KAAKU,IAAkB,YAAXpD,EAAE6B,SAAyB7B,EAAE0C,KAAKU,OAASpD,EAAE0C,KAAKU,IAAO3B,EAAOzB,EAAG,QAAQ,GACjH,KAAOuC,EAAMK,EAAMe,QAAQ,CAC1B,MAAM3D,EAAI4C,EAAML,GACQ,aAAXvC,EAAE6B,MAAuC,MAAhB7B,EAAE0C,KAAKC,MAG5CG,EAAS6B,EAAWD,GAAW,EAAMjD,EAAOzB,EAAG,QAAQ,EAAMiC,IAC7DuC,GAAQ,EACRE,IAAchC,MAAOU,IAAKN,OAG1B4B,EAAUlC,KAAKxC,GACfwE,EAAQA,GAA+B,IAArBE,EAAUf,QAA2B,YAAX3D,EAAE6B,KAC1CU,IAAQK,EAAMe,OAAS,IAEzBb,EADG0B,GAA8B,IAArBE,EAAUf,OACbuB,EAAWR,EAAU,IAGrBC,EAAWD,GAAW,EAAO,KAAMD,KAI/ClC,IAGD,OAAOO,EAgHYsC,CAAYxC,EAAOC,EAAalB,GAChDiB,EAAQ,WAGL,GAAkB,aAAdjB,EAAKE,KAAqB,CAClC,MACMwD,EADgBpC,IAAaD,GAAgBY,GAA6B,aAAhB7B,EAAOF,MAA4C,MAArBE,EAAOW,KAAKC,QAAmB,IAAK,KAAKf,SAASD,EAAKe,KAAKC,MAChI,gBAAoBhB,EAAK8B,OAAkB,WAAT,OAC5DV,GAAQtB,EAAOE,EAAM0D,EAAG,KAAMpD,GAG/B,GAAIN,EAAKe,KAAKU,MAAQc,EAAY,CACjC,MAAMoB,EAAYnD,GAAYT,EAAMS,IAAaT,EAAMC,GACvDoB,IAASuC,EAAY,IAAM,IAAM3D,EAAKe,KAAKU,IAGxCzB,EAAKS,MACRW,GAAQ,OAETZ,EAAWR,IAERoB,IACHD,GAAmB,SAATjB,GAAoBmB,EAAiCD,EAAnB,UAAYA,GAErC,aAAhBhB,EAAOF,MAAwBG,IAClCc,GAAUf,EAAOW,KAAK6C,OAEhBzC,4CC1NR,SAAS0C,EAAeC,EAAKlD,GAC5B,MAAMmD,EAAQD,EAAIE,MAAM,MAAMV,IAAIzD,GAAKA,EAAEmC,QACzC,IAAIiC,EAAK,EACL5F,EAAI,EACR,KAAO4F,EAAKrD,GAAOvC,EAAI0F,EAAM/B,QAC5BiC,GAAMF,EAAM1F,GACZA,IAED,OAAOA,EAAI,oFAyBX6F,YAAaC,EAAMvD,EAAM,GACxBwD,KAAKD,KAAOA,EACZC,KAAKxD,IAAMA,EACXwD,KAAKzG,MAAQuC,KAAM,OAAQQ,YAAc2D,MAAOzD,EAAK0D,IAAKH,EAAKnC,QAC/DoC,KAAKG,OAASH,KAAKzG,MACnByG,KAAKI,aACLzF,OAAOC,eAAeoF,KAAKG,MAAO,SACjCpF,MACC,OAAuB,IAAhBiF,KAAKpC,UAGdoC,KAAKG,MAAME,KAAO,KACVL,KAAKG,MAAMH,KAAKG,MAAMvC,OAAS,IAGxC0C,OAAQ7E,EAAG8E,EAAQ,IAClB,OAAO,IAAIC,OAAO/E,EAAEgF,QAAQ,yBAA0B,QAASF,GAEhEG,IAAK5E,EAAM6E,GACV,MAAMC,EAAOZ,KACPpE,EAAOjB,OAAOkG,QAClBvE,YAAc2D,MAAOD,KAAKc,QAASZ,IAAKF,KAAKxD,IAAKG,SACnDgE,GACC7E,SAWF,OATAnB,OAAOC,eAAegB,EAAM,QAC3Bb,QACQ6F,EAAKb,KAAKgB,UAChBnF,EAAKqE,MACLrE,EAAKsE,KAAOU,EAAKb,KAAKnC,UAIzBoC,KAAKpE,KAAKU,SAASG,KAAKb,GACjBA,EAERqE,SAAUlB,GACT,MAAMnD,EAAOoE,KAAKU,OAAO3B,GAKzB,OAJAiB,KAAKG,MAAM1D,KAAKb,GAChBA,EAAKqE,MAAQD,KAAKxD,IAClBZ,EAAKiC,UAAY4B,EAAcO,KAAKD,KAAMnE,EAAKqE,OAC/CrE,EAAKsE,IAAM,KACJtE,EAERsE,IAAKS,GACJ,IAAI/E,EAAOoE,KAAKG,MAAMa,MAMtB,OALIL,IACH/E,EArEH,SAASqF,EAAOC,EAASC,GAkBxB,OAjBAxG,OAAOyG,KAAKD,GAAQ5E,QAAS8E,KAI3BH,EAAQ3F,eAAe8F,IACC,iBAAjBH,EAAQG,IACbH,EAAQG,aAAgBC,MAQ1BJ,EAAQG,GAAOF,EAAOE,GANtBJ,EAAMC,EAAQG,GAAMF,EAAOE,MAStBH,EAmDED,CAAMrF,EAAM+E,IAEpB/E,EAAKsE,IAAMF,KAAKxD,IAChBZ,EAAK2F,QAAU9B,EAAcO,KAAKD,KAAMnE,EAAKsE,KACtCtE,EAERb,IAAK6C,EAAQ4D,EAAQ,GACpB,OAAe,IAAX5D,EACIoC,KAAKD,KAAK0B,OAAOzB,KAAKxD,IAAMgF,GAE7BxB,KAAKD,KAAK2B,OAAO1B,KAAKxD,IAAMgF,EAAO5D,GAE3C+D,YACC3B,KAAKI,UAAU3D,KAAKuD,KAAKxD,KAE1BoF,UACC,MAAMpF,EAAMwD,KAAKI,UAAUY,MAC3B,OAAOhB,KAAKD,KAAKgB,UAAUvE,EAAKwD,KAAKxD,KAEtCZ,WACC,OAAOoE,KAAKG,MAAMH,KAAKG,MAAMvC,OAAS,GAEvCiE,GAAIL,EAAQ,GAIX,OAHAxB,KAAKc,QAAUd,KAAKxD,IACpBwD,KAAKxD,KAAOgF,EACZxB,KAAK8B,OAAQ,EACN9B,KAER+B,OAQC,OAPA/B,KAAKc,QAAUd,KAAKxD,IACfwD,KAAK8B,MAIT9B,KAAK8B,OAAQ,EAHb9B,KAAKxD,MAKCwD,KAERgC,QACC,OAAOhC,KAAKxD,KAAOwD,KAAKD,KAAKnC,OAE9BqE,MAAO5E,GACN,MAAMqC,EAAMM,KAAKjF,MACjB,OAAIsC,aAAemD,OACXd,EAAIuC,MAAM5E,GAEXqC,EAAIwC,WAAW7E,GAEvBkB,aACC,OAAOyB,KAAKD,KAAK2B,OAAO,EAAG1B,KAAKxD,KAEjC2F,SAAU9E,GACT,MAAMqC,EAAMM,KAAKzB,OACjB,OAAIlB,aAAemD,OACXd,EAAIuC,MAAM5E,GAEXqC,EAAI0C,SAAS/E,8FChFP,SAAgB0C,GAC9B,MAAMa,EAAO,IAAIyB,UAAUtC,GACrBuC,GACLC,SACC,GAAuB,WAAnB3B,EAAKhF,KAAKE,KAAmB,CAChC,MAAMF,EAAOgF,EAAKhF,KAClB,GAAIgF,EAAKqB,MAAMrB,EAAKhF,KAAKe,KAAK6F,OAAQ,CACrC,MAAMC,EAAe7B,EAAKuB,SAAS,UACnC,IACEM,GACAA,GAAgBA,EAAa,GAAG7E,OAAS,GAAM,EAIhD,OAFAgD,EAAKiB,KAAK3B,MACVtE,EAAKe,KAAKU,IAAMzB,EAAKmE,MACd,OAIL,CACJ,MAAM2C,EAAa9B,EAAKqB,MAAM,YAC9B,GAAIS,EAEH,OADA9B,EAAKX,MAAM,UAAWtD,MAAO6F,MAAOE,EAAW,OACxC,IAIVC,UACC,MAAMV,EAAQrB,EAAKqB,MAAM,wBAA0BrB,EAAKqB,MAAM,uBAC9D,GAAIA,EAGH,OAFAW,QAAQC,IAAI,UAAWZ,EAAM,IAC7BrB,EAAKiB,GAAGI,EAAM,GAAGrE,QAAQ8C,IAAI,YACtB,GAGToC,UACC,MAAMb,EAAQrB,EAAKqB,MAAMc,GACrBd,GACHrB,EACEiB,GAAGI,EAAM,GAAGrE,QACZ8C,IAAI,WAAY/D,MAAOU,IAAK4E,EAAM,OAGtCe,WACC,GAAuB,aAAnBpC,EAAKhF,KAAKE,MAAuB8E,EAAKqB,MAAMrB,EAAKhF,KAAKe,KAAK6C,OAE9D,OADAoB,EAAKiB,KAAK3B,OACH,EAER,MAAM+B,EAAQrB,EAAKqB,MAAM,eACzB,OAAIA,GACHrB,EAAKX,MAAM,YAAatD,MAAOC,KAAMqF,EAAM,GAAIzC,OAAQyD,IAAK,IAAKC,IAAK,IAAKC,IAAK,KAAKlB,EAAM,QACpF,QAFR,GAKDmB,MACC,MAAMnB,EAAQrB,EAAKqB,MAAM,UACzB,GAAIA,GAA6B,IAApBA,EAAM,GAAGrE,OAErB,OADAgD,EAAKiB,KAAKnB,IAAI,KAAM/D,MAAOU,IAAK,QACzB,GAGTgG,QACC,GAAIzC,EAAKqB,MAAM,KAEd,OADArB,EAAKiB,KAAKnB,IAAI,KAAM/D,MAAOU,IAAK,QACzB,GAGTiG,QACC,GAAI1C,EAAKqB,MAAM,KAEd,OADArB,EAAKiB,KAAKnB,IAAI,KAAM/D,MAAOU,IAAK,QACzB,GAGTkG,YACC,GAAI3C,EAAKqB,MAAM,KAEd,OADArB,EAAKiB,KAAKnB,IAAI,MACP,GAGT8C,QACC,GAAI5C,EAAKqB,MAAM,MAEd,OADArB,EAAKiB,GAAG,GAAGnB,IAAI,MAAO/D,MAAOU,IAAK,SAC3B,GAGToG,SACC,MAAMxB,EAAQrB,EAAKqB,MAAM,iBACzB,GAAIA,EAEH,OADArB,EAAKiB,GAAGI,EAAM,GAAGrE,QAAQ8C,IAAI,UAAW/D,MAAOU,IAAK4E,EAAM,OACnD,GAGTyB,UAEC,MAAMzB,EAAQrB,EAAKqB,MAAM,sBACzB,GAAIA,EAIH,OAHArB,EACEiB,GAAGI,EAAM,GAAGrE,QACZ8C,IAAI,WAAY/D,MAAOU,IAAK4E,EAAM,OAC7B,GAGT0B,YACC,MAAM1B,EAAQrB,EAAKqB,MAAM,uBACzB,GAAIA,EAIH,OAHArB,EACEiB,GAAGI,EAAM,GAAGrE,QACZ8C,IAAI,aAAc/D,MAAOU,IAAK4E,EAAM,OAC/B,GAGT2B,YACC,GAAIhD,EAAKqB,MAAM,OAEd,OADArB,EAAKiB,KAAKnB,IAAI,cACP,IAKV,MAAQE,EAAKoB,SAAS,CACrB,OAAQpB,EAAKhF,KAAKE,MACjB,IAAK,SACJwG,EAAMC,SACN,MAED,IAAK,UACJ,MAED,SAEED,EAAMK,QACNL,EAAMC,OACND,EAAMsB,UACNtB,EAAMiB,UACNjB,EAAMmB,OACNnB,EAAMQ,QACNR,EAAMU,SACNV,EAAMgB,MACNhB,EAAMe,MACNf,EAAMc,IACNd,EAAMkB,MACNlB,EAAMoB,QACNpB,EAAMqB,WACLE,KAAKrI,GAAKA,KAIdoF,EAAKmB,OAEN,OAAOnB,GA5MR,MAAAkD,KAAA/J,EAAA,gCAEA,MAoDMgJ,EAAgB,IAAIvC,aAnDzB,QACA,QACA,QACA,OACA,QACA,QACA,QACA,WACA,WACA,UACA,SACA,KACA,OACA,OACA,SACA,UACA,UACA,MACA,WACA,OACA,KACA,SACA,KACA,aACA,MACA,MACA,SACA,QACA,SACA,OACA,QACA,MACA,SACA,MACA,OACA,QACA,OACA,QACA,aACA,UACA,YACA,SACA,YACA,UACA,SACA,OACA,OACA,QACA,aAG8CpB,KAAK,4GCtDpD,MAAM2E,EAAa9I,GAAmB,MAATA,GAAmC,iBAAVA,GAAuC,mBAAVA,QAI9D+I,EACpBlE,YAAaK,GACZH,KAAKG,SAAW8D,OAAO9D,GACvBH,KAAKjF,IAAMiF,KAAKjF,IAAImJ,KAAKlE,MACzBA,KAAKmE,IAAMnE,KAAKmE,IAAID,KAAKlE,MAE1BmE,IAAKC,GACJ,OAAO,IAAIJ,MAAUhE,KAAKG,MAAOiE,QAElCrJ,IAAK8B,EAAOwH,EAAUC,EAAS7J,EAAQ8J,GACtC,IACItJ,EADAuJ,EAAW,EAEf,GAAIF,EACHrJ,EAAQR,OAGR,IACCQ,EAAQR,KACH4J,GAA8B,mBAAXE,GAAyB1H,EAAMe,OAAS,GAAKmG,EAAU9I,IAE9EsJ,EADAtJ,MAGDuJ,EAAW,EAEZ,MAAOC,IAGR,IAAIC,EAAUzJ,EACd,GAAiB,IAAbuJ,EAAgB,CACnB,IAAIvK,EAAI+F,KAAKG,MAAMvC,OAAS,EAC5B,MAAMyD,EAAMxE,EAAM,GAClB,KAAO5C,GAAK,GAAG,CACd,GAAIoH,KAAOrB,KAAKG,MAAMlG,IAAY,IAANA,EAAS,CACpCyK,EAAU1E,KAAKG,MAAMlG,GACrB,MAEDA,KAIF,KAAOuK,EAAW3H,EAAMe,QAAQ,CAC/B,MAAMyD,EAAMxE,EAAM2H,GAElB,GADAvJ,EAAQyJ,EAAQrD,GACZkD,EAAQ,CACX,GAAIC,IAAa3H,EAAMe,OAAS,EAC/B,OACCP,UACC,OAAOqH,EAAQrD,IAEhBhE,QAASpC,GACRyJ,EAAQrD,GAAOpG,IAId8I,EAAU9I,KACbA,KACAyJ,EAAQrD,GAAOpG,QAIhB,GAAI8I,EAAU9I,IAAUuJ,EAAW3H,EAAMe,OAAS,EACjD,OAIF8G,EAAUzJ,EACVuJ,IAGD,OAAIA,IAAa3H,EAAMe,QAAUyG,GAA6B,mBAAVpJ,EAC5CA,EAAM0J,MAAMD,EAASL,GAEtBpJ,+GC3ET,IAAA2J,EAAAC,EAAA9K,EAAA,IACA+K,EAAAD,EAAA9K,EAAA,6DA+FA,SAAiB8E,EAAM/C,EAAO,QAC7B,OA9DD,SAASiJ,EAAelG,GACvB,IAAImG,EAAM,EAEV,IAAIC,EACJ,IAAIC,EAEJ,IAAI1I,EAAM,EACV,MAAMO,KACN,KAAOP,EAAMqC,EAAKjB,QAAQ,CACzB,MAAMhC,EAAOiD,EAAKrC,IACZG,KAACA,EAADb,KAAOA,GAAQF,EACH,QAAdA,EAAKE,MAAiC,eAAdF,EAAKE,MAAyBa,EAAKwI,QAC1DF,GACmB,QAAlBA,EAASnJ,MACC,QAATA,GAAkBa,EAAKC,MAAQD,EAAKyI,UAAYH,EAAStI,KAAKyI,SACjEJ,IAEY,QAATlJ,GAAkBa,EAAK6C,OAAS7C,EAAKyI,UAAYH,EAAStI,KAAKyI,SAClEJ,KAGgB,eAATlJ,IACa,MAAjBa,EAAKwI,QACRH,IAEyB,MAAjBrI,EAAKwI,SACbH,KAGU,IAARA,IACHjI,EAAON,KAAK0C,EAAW8F,EAAUF,EAAclG,EAAKwG,OAAOH,EAAc,EAAG1I,EAAM0I,EAAc,MAChGD,EAAW,KACXzI,EAAM0I,IAIM,QAATpJ,EACCa,EAAKC,MACRqI,EAAWrJ,EACXsJ,EAAc1I,EACdwI,KAEQrI,EAAK2I,aACbvI,EAAON,KAAK0C,EAAWvD,IAGP,eAATE,GAA0C,MAAjBa,EAAKwI,UACtCF,EAAWrJ,EACXsJ,EAAc1I,EACdwI,KAIc,IAARA,GACRjI,EAAON,KAAK0C,EAAWvD,IAExBY,IAED,OAAOO,EAIAgI,CAAclG,gBA3FtB,MAAM0G,GACL1G,MAAME,EAAMyG,KACXzG,EAAOA,EAAKa,MAAM,uBACM,EAAAkF,EAAAW,UAAiB,EAAAb,EAAAa,SAAgB1G,EAAK,IAAIxF,WAAWwF,EAAK,UAAUyG,OAKxFrG,EAAa,CAACvD,EAAM4J,IACP,QAAd5J,EAAKE,KACJ0J,GAAWA,EAAQ5H,aACThC,EAAKe,KAAKyI,kBAAkBI,EAAQpG,KAAK,gBAGzCxD,EAAKe,KAAKyI,gBAGF,eAAdxJ,EAAKE,KACa,MAAtBF,EAAKe,KAAKwI,WACHI,EAAI3J,EAAKe,KAAKW,IAAI1B,EAAKe,KAAKoC,KAAMyG,uBAGpB,EAAAV,EAAAW,UAAiB,EAAAb,EAAAa,SAAgB7J,EAAKe,KAAK+I,YAAYnM,4BAGvDqC,EAAKe,KAAK6I,SAAW,IAAI/E,QAAQ,SAAU,kGC3BvD,SAAgBV,GAC9B,MAAMa,EAAO,IAAIyB,UAAUtC,GACrBuC,GACLqD,WACC,GAAI/E,EAAKqB,MAAM,KAAM,CACpB,MAAMA,EAAQrB,EAAKqB,MAAM,wBACzB,GAAIA,EAAO,CACV,MAAMmD,EAAUnD,EAAM,GAGtB,OAFArB,EAAKX,MAAM,OAAQtD,MAAOyI,UAASxI,MAAM,KACzCgE,EAAKiB,GAAGuD,EAAQxH,OAAS,IAClB,EAEH,CACJ,MAAMgI,EAAahF,EAAKqB,MAAM,2BAC9B,GAAI2D,EAAY,CACf,MAAMR,EAAUQ,EAAW,GAI3B,OAHAhF,EACEiB,GAAG+D,EAAW,GAAGhI,QACjB8C,IAAI,OAAQ/D,MAAOyI,UAAS5F,OAAO,MAC9B,MAKXqG,eACC,GAAIjF,EAAKqB,MAAM,WAGd,OAFArB,EAAKX,MAAM,WACXW,EAAKiB,GAAG,IACD,GAGTiE,aACC,GAAIlF,EAAKqB,MAAM,UAEd,OADArB,EAAKiB,GAAG,GAAG3B,OACJ,GAGT6F,WACKnF,EAAKqB,MAAM,OACdrB,EAAKiB,GAAG,GAAG3B,KAAKvD,MAAO2I,aAAa,MAC7B,GAEC1E,EAAKqB,MAAM,MACnBrB,EAAKiB,KAAK3B,OACH,QAFH,EAKN8F,YACC,MAAM/D,EAAQrB,EAAKqB,MAAM,6CACzB,GAAIA,GAASA,EAAM,GAAI,CACtB,IAAKgE,EAAMC,EAAQC,EAAM3D,GAASP,EAClC,MAAMmE,EAAaF,EAASA,EAAO,GAAK,KAaxC,OAZIA,IACHA,EAASA,EAAOxE,OAAO,IAEpBc,GACH5B,EAAKX,MAAM,QAAStD,MAAOwJ,OAAMD,SAAQE,aAAY5D,WACrD5B,EAAKiB,GAAGoE,EAAKrI,SAGbgD,EACEiB,GAAGoE,EAAKrI,QACR8C,IAAI,QAAS/D,MAAOwJ,OAAMD,SAAQE,iBAE9B,IAGTD,OACmBvF,EAAKqB,MAAMoE,GAC7B,IAAK,IAAK,IAAK,IAAK,KAAKxK,SAAS+E,EAAKhF,KAAKe,KAAKyJ,YAAa,CAE7D,IAAI/L,EADJuG,EAAKe,YAEL,MAAM2E,KAAa1F,EAAKhF,KAAKe,KAAK6F,QAClC,MAAQnI,IAAMuG,EAAKoB,WAClB3H,EAAIuG,EAAKqB,MAAMqE,KACT1F,EAAKiB,KAEZ,GAAIxH,EAAG,CACN,MAAMqL,EAAa9E,EAAKgB,UAIxBhB,EAAKiB,GAAGyE,EAAQ1I,QAAQsC,KAAKvD,MAAO+I,qBAGjC,CAEJ,MAAMa,EAAc,6CACdtE,EAAQrB,EAAKiB,IAAI,GAAGI,MAAMsE,GAC5BtE,IACHrB,EAAKhF,KAAKX,MAAQgH,EAAM,GACxBrB,EAAKiB,GAAGI,EAAM,GAAGrE,QAAQsC,SAI5BH,OACC,MAAMyG,EAAW5F,EAAKrH,KAAK+C,SAASsE,EAAKrH,KAAK+C,SAASsB,OAAS,GAC5D4I,GAA8B,SAAlBA,EAAS1K,MACxB0K,EAAStG,IAAMU,EAAKpE,IACpBgK,EAAS7J,KAAK6I,SAAW5E,EAAK7F,IAAI,IAGlC6F,EAAKiB,GAAG,GAAGnB,IAAI,QAAS/D,MAAO6I,QAAS5E,EAAK7F,IAAI,OAGnD2K,aACC,MAAMzD,EAAQrB,EAAKqB,MAClB,IAAIzB,WAAW6F,eAAsBI,MAEtC,GAAIxE,EAAO,CACV,MAAOyE,EAAKT,EAAMU,EAAKxB,EAASyB,EAAKlB,GAAczD,EACnD,IAAI3E,EACAyB,EACJ,GAAgB,MAAZoG,EAAiB,CACpB,MAAMlD,EAAQyD,EAAWzD,MACxB,iCAED3E,EAAK2E,EAAM,GACXlD,EAAOkD,EAAM,GAEdrB,EAAKiB,GAAGoE,EAAKrI,QAAQ8C,IAAI,cACxB/D,MAAO+I,aAAYP,UAAS7H,KAAIyB,aAMpC,MAAQ6B,EAAKoB,SAAS,CACrB,OAAQpB,EAAKhF,KAAKE,MACjB,IAAK,MACA8E,EAAKhF,KAAKe,KAAKC,MACjB0F,EAAMyD,OAAQzD,EAAM0D,WAAWnC,KAAKrI,GAAKA,KAG1C8G,EAAMyD,SAEP,MAED,IAAK,OACJzD,EAAM6D,OACN,MAED,IAAK,UACJ7D,EAAMwD,aACN,MAED,SAEExD,EAAMqD,SACNrD,EAAMuD,aACNvD,EAAMoD,WACNpD,EAAMvC,MACL8D,KAAKrI,GAAKA,KAKdoF,EAAKmB,OAEN,OAAOnB,GApKR,MAAAkD,KAAA/J,EAAA,gCAEA,MAAMsM,EAAW,KACXI,EAAS,qGCHf,IAAA7B,EAAAC,EAAA9K,EAAA,IACA8M,EAAAhC,EAAA9K,EAAA,IACA+K,EAAAD,EAAA9K,EAAA,IACA+M,EAAAjC,EAAA9K,EAAA,IACAgN,EAAAlC,EAAA9K,EAAA,8DAGCiN,0BACAC,mBACAC,2BACAC,oBACAnD,2DCXDtK,EAAOD,QAAUM,EAAQ,GAAc0L","file":"parse.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"parse\"] = factory();\n\telse\n\t\troot[\"parse\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 7);\n","export default format;\n\nfunction isVal (node) {\n\treturn [\"number\", \"literal\", \"string\"].includes(node.type);\n}\n\nfunction isLit (node) {\n\treturn [\"keyword\", \"number\", \"literal\", \"string\"].includes(node.type);\n}\n\nfunction isOP (node) {\n\treturn [\"operation\", \",\", \".\", \":\", \"=>\"].includes(node.type);\n}\n\nfunction isOPNoAccessor (node) {\n\treturn [\"operation\", \",\", \":\"].includes(node.type);\n}\n\nfunction isSign (node) {\n\treturn ![\"comment\", \"linebreak\", \";\"].includes(node.type);\n}\n\nfunction formatChain (chain, before, after, isSet = false) {\n\tlet result = \"\";\n\tlet idx = 0;\n\tlet isLoc = chain[0] && chain[0].type !== \"literal\";\n\tconst assigmentExp = [\"++\", \"--\", \"=\", \"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"**=\", \"<<=\", \">>=\", \">>>=\", \"&=\", \"^=\", \"|=\"];\n\tconst isSetHere = (before && before.type === \"operation\" && [\"++\", \"--\"].includes(before.data.val)) ||\n\t(after && after.type === \"operation\" && assigmentExp.includes(after.data.val));\n\tisSet = isSet || isSetHere;\n\tlet chainList = [];\n\tconst formatList = (list, isCall, args, isLast) => {\n\t\tlet result = `_$g(`;\n\t\tconst locData = list[0];\n\t\tif (isLoc) {\n\t\t\tlist = list.slice(1);\n\t\t}\n\t\tresult += `[${list.map(formatNode).join(\",\")}],`;\n\t\tresult += isCall ? `[${args}],` : `null,`;\n\t\tresult += isLoc ? `true,` : `false,`;\n\t\tif (isLoc) {\n\t\t\tresult += `${formatNode(locData)},`;\n\t\t\tresult += isLast ? \"true\" : \"false\";\n\t\t}\n\t\telse {\n\t\t\tresult += `()=>${locData.data.val}`;\n\t\t\tif (isLast) {\n\t\t\t\tresult += `,_$v=>${locData.data.val}=_$v`;\n\t\t\t}\n\t\t}\n\t\tresult += isLast ? \").val\" : \")\";\n\t\treturn result;\n\n\t\t// get(chain, callArgs, isLocal, getter/localData, setter);\n\t};\n\tconst formatNode = i => i.data.val ? (i.type === \"literal\" ? `\"${i.data.val}\"` : i.data.val) : format(i, \"code\", true);\n\twhile (idx < chain.length) {\n\t\tconst i = chain[idx];\n\t\tconst call = i.type === \"brackets\" && i.data.open === \"(\";\n\t\tif (call) {\n\n\t\t\tresult = formatList(chainList, true, format(i, \"code\", true, isSet));\n\t\t\tisLoc = true;\n\t\t\tchainList = [{data: {val: result}}];\n\t\t}\n\t\telse {\n\t\t\tchainList.push(i);\n\t\t\tisLoc = isLoc || (chainList.length === 1 && i.type !== \"literal\");\n\t\t\tif (idx === chain.length - 1) {\n\t\t\t\tif (isLoc && chainList.length === 1) {\n\t\t\t\t\tresult = formatNode(chainList[0]);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tresult = formatList(chainList, false, null, isSetHere);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tidx++;\n\t}\n\n\treturn result;\n}\n\nfunction format (parent, type = \"root\", skipBrackets = false, isSet = false) {\n\tconst nodes = parent.children || [];\n\tconst snodes = [];\n\tlet brk = false;\n\tlet prevNode;\n\tnodes.forEach((node, idx) => {\n\t\tif (isSign(node)) {\n\t\t\tsnodes.push(node);\n\t\t\tconst block = prevNode && prevNode.type !== \"brackets\" && prevNode.data.open === \"{\";\n\t\t\tif (prevNode && (brk === \";\" || (brk === \"linebreak\" && (!isOP(node) && !isOP(prevNode) && !block)))) {\n\t\t\t\tprevNode.brk = true;\n\t\t\t}\n\t\t\tbrk = false;\n\t\t\tprevNode = node;\n\t\t}\n\t\telse if (node.type === \";\" || (node.type === \"linebreak\" && !brk)) {\n\t\t\tbrk = node.type;\n\t\t}\n\t\t// if (idx >= node.length - 1) {\n\t\t// \tnode.brk = true;\n\t\t// }\n\t});\n\tlet result = \"\";\n\tif (parent.type === \"brackets\" && !skipBrackets) {\n\t\tresult += parent.data.open;\n\t}\n\tprevNode = null;\n\tlet chain;\n\tlet beforeChain;\n\tlet declaration = false;\n\tlet leftSide = false;\n\tlet line;\n\tlet leftSideLit = false;\n\n\tsnodes.forEach((node, idx) => {\n\t\tconst nextNode = snodes[idx + 1];\n\t\tif (node.type === \"keyword\" && node.data.val === \"function\") {\n\t\t\tnode.fn = true;\n\t\t\tnode.fnKeyword = true;\n\t\t\tlet argsNode = snodes[idx + 1];\n\t\t\tif (argsNode && argsNode.type === \"literal\") {\n\t\t\t\targsNode.fn = true;\n\t\t\t\targsNode.fnName = true;\n\t\t\t\targsNode = snodes[idx + 2];\n\t\t\t}\n\t\t\tif (argsNode && argsNode.type === \"brackets\") {\n\t\t\t\targsNode.fn = true;\n\t\t\t\targsNode.fnArgs = true;\n\t\t\t}\n\t\t}\n\t\telse if (nextNode && nextNode.type === \"=>\") {\n\t\t\tnode.fn = true;\n\t\t\tnode.fnArgs = true;\n\t\t}\n\n\t\tconst isLast = idx >= snodes.length - 1;\n\t\tconst literal = node.type === \"literal\";\n\t\tconst lineStart = !prevNode || prevNode.brk;\n\t\tconst codeNode = [\"root\", \"code\"].includes(type);\n\t\tconst blockStart = ((prevNode && prevNode.type === \",\") || lineStart) && codeNode;\n\t\tconst argStart = ((prevNode && prevNode.type === \",\") || lineStart) && type === \"brackets\";\n\t\tconst opStart = prevNode && ([\"operation\", \":\"].includes(prevNode.type) || prevNode.type === \"keyword\") && !blockStart;\n\t\tconst chainable = [\"literal\", \"number\", \"string\"].includes(node.type) || (!declaration && leftSide);\n\n\t\t// forceDeclaration ...rest exception\n\t\tif (blockStart || argStart) {\n\t\t\tleftSideLit = false;\n\t\t}\n\n\t\tif (lineStart) {\n\t\t\tif (line) {\n\t\t\t\tresult += line;\n\t\t\t}\n\t\t\tline = \"\";\n\t\t\tdeclaration = node.type === \"keyword\" && [\"const\", \"let\", \"var\"].includes(node.data.val);\n\t\t\t// leftSide = true;\n\t\t}\n\n\n\t\tif (opStart && leftSideLit) {\n\t\t\tleftSide = false;\n\t\t}\n\n\t\tif ((declaration && blockStart) || argStart) {\n\t\t\tleftSide = true;\n\t\t}\n\n\t\tif (leftSide && chainable) {\n\t\t\tleftSideLit = true;\n\t\t}\n\n\n\t\tif (!chain && type !== \"destructuring\" && chainable && !leftSide && (opStart || blockStart)) {\n\t\t\tbeforeChain = prevNode;\n\t\t\tchain = [];\n\t\t}\n\n\t\tlet skipOutput = false;\n\t\tif (chain) {\n\t\t\tconst op = isOPNoAccessor(node);\n\t\t\tskipOutput = true;\n\t\t\tif (!isOP(node)) {\n\t\t\t\tchain.push(node);\n\t\t\t}\n\n\n\t\t\tif (node.brk || op || isLast) {\n\t\t\t\tskipOutput = !op && (node.brk || isLast);\n\t\t\t\tconst space = beforeChain && isLit(beforeChain) ? \" \" : \"\";\n\t\t\t\tline += space + formatChain(chain, beforeChain, node);\n\t\t\t\tchain = null;\n\t\t\t}\n\t\t}\n\t\telse if (node.type === \"brackets\") {\n\t\t\tconst destructuring = leftSide && (declaration || (lineStart && parent.type === \"brackets\" && parent.data.open === \"(\")) && [\"{\", \"[\"].includes(node.data.open);\n\t\t\tconst t = destructuring ? \"destructuring\" : (!node.fnArgs ? \"code\" : \"brackets\");\n\t\t\tline += format(node, t, null, isSet);\n\t\t}\n\n\t\tif (node.data.val && !skipOutput) {\n\t\t\tconst needSpace = prevNode && isLit(prevNode) && isLit(node);\n\t\t\tline += (needSpace ? \" \" : \"\") + node.data.val;\n\t\t}\n\n\t\tif (node.brk) {\n\t\t\tline += \";\\n\";\n\t\t}\n\t\tprevNode = node;\n\t});\n\tif (line) {\n\t\tresult += type === \"root\" && !declaration ? \"return \" + line : line;\n\t}\n\tif (parent.type === \"brackets\" && !skipBrackets) {\n\t\tresult += parent.data.close;\n\t}\n\treturn result;\n}\n","function getLineNumber (str, idx) {\n\tconst lines = str.split(\"\\n\").map(s => s.length);\n\tlet lc = 0;\n\tlet i = 0;\n\twhile (lc < idx && i < lines.length) {\n\t\tlc += lines[i];\n\t\ti++;\n\t}\n\treturn i - 1;\n}\n\nfunction merge (current, update) {\n\tObject.keys(update).forEach((key) => {\n\t\t// if update[key] exist, and it's not a string or array,\n\t\t// we go in one level deeper\n\t\tif (\n\t\t\tcurrent.hasOwnProperty(key) &&\n\t\t\ttypeof current[key] === \"object\" &&\n\t\t\t!(current[key] instanceof Array)\n\t\t) {\n\t\t\tmerge(current[key], update[key]);\n\n\t\t\t// if update[key] doesn't exist in current, or it's a string\n\t\t\t// or array, then assign/overwrite current[key] to update[key]\n\t\t}\n\t\telse {\n\t\t\tcurrent[key] = update[key];\n\t\t}\n\t});\n\treturn current;\n}\n\nexport default class ParseCtrl {\n\tconstructor (text, idx = 0) {\n\t\tthis.text = text;\n\t\tthis.idx = idx;\n\t\tthis.root = {type: \"root\", children: [], start: idx, end: text.length};\n\t\tthis.stack = [this.root];\n\t\tthis.copyStack = [];\n\t\tObject.defineProperty(this.stack, \"empty\", {\n\t\t\tget () {\n\t\t\t\treturn this.length === 0;\n\t\t\t},\n\t\t});\n\t\tthis.stack.last = () => {\n\t\t\treturn this.stack[this.stack.length - 1];\n\t\t};\n\t}\n\tregexp (s, flags = \"\") {\n\t\treturn new RegExp(s.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\"), flags);\n\t}\n\tadd (type, params) {\n\t\tconst ctrl = this;\n\t\tconst node = Object.assign(\n\t\t\t{children: [], start: this.lastIdx, end: this.idx, data: {}},\n\t\t\tparams,\n\t\t\t{type}\n\t\t);\n\t\tObject.defineProperty(node, \"text\", {\n\t\t\tget () {\n\t\t\t\treturn ctrl.text.substring(\n\t\t\t\t\tnode.start,\n\t\t\t\t\tnode.end || ctrl.text.length\n\t\t\t\t);\n\t\t\t},\n\t\t});\n\t\tthis.node.children.push(node);\n\t\treturn node;\n\t}\n\tstart (...args) {\n\t\tconst node = this.add(...args);\n\t\tthis.stack.push(node);\n\t\tnode.start = this.idx;\n\t\tnode.lineStart = getLineNumber(this.text, node.start);\n\t\tnode.end = null;\n\t\treturn node;\n\t}\n\tend (params) {\n\t\tlet node = this.stack.pop();\n\t\tif (params) {\n\t\t\tnode = merge(node, params);\n\t\t}\n\t\tnode.end = this.idx;\n\t\tnode.lineEnd = getLineNumber(this.text, node.end);\n\t\treturn node;\n\t}\n\tget (length, shift = 0) {\n\t\tif (length === 1) {\n\t\t\treturn this.text.charAt(this.idx + shift);\n\t\t}\n\t\treturn this.text.substr(this.idx + shift, length);\n\t}\n\tstartCopy () {\n\t\tthis.copyStack.push(this.idx);\n\t}\n\tendCopy () {\n\t\tconst idx = this.copyStack.pop();\n\t\treturn this.text.substring(idx, this.idx);\n\t}\n\tget node () {\n\t\treturn this.stack[this.stack.length - 1];\n\t}\n\tgo (shift = 1) {\n\t\tthis.lastIdx = this.idx;\n\t\tthis.idx += shift;\n\t\tthis.moved = true;\n\t\treturn this;\n\t}\n\tnext () {\n\t\tthis.lastIdx = this.idx;\n\t\tif (!this.moved) {\n\t\t\tthis.idx++;\n\t\t}\n\t\telse {\n\t\t\tthis.moved = false;\n\t\t}\n\t\treturn this;\n\t}\n\tisEnd () {\n\t\treturn this.idx >= this.text.length;\n\t}\n\tmatch (val) {\n\t\tconst str = this.get();\n\t\tif (val instanceof RegExp) {\n\t\t\treturn str.match(val);\n\t\t}\n\t\treturn str.startsWith(val);\n\t}\n\tget before () {\n\t\treturn this.text.substr(0, this.idx);\n\t}\n\tprecedes (val) {\n\t\tconst str = this.before;\n\t\tif (val instanceof RegExp) {\n\t\t\treturn str.match(val);\n\t\t}\n\t\treturn str.endsWith(val);\n\t}\n}\n","import ParseCtrl from \"./parse-ctrl.js\";\n\nconst keywords = [\n\t\"async\",\n\t\"await\",\n\t\"break\",\n\t\"case\",\n\t\"class\",\n\t\"catch\",\n\t\"const\",\n\t\"continue\",\n\t\"debugger\",\n\t\"default\",\n\t\"delete\",\n\t\"do\",\n\t\"else\",\n\t\"enum\",\n\t\"export\",\n\t\"extends\",\n\t\"finally\",\n\t\"for\",\n\t\"function\",\n\t\"goto\",\n\t\"if\",\n\t\"import\",\n\t\"in\",\n\t\"instanceof\",\n\t\"let\",\n\t\"new\",\n\t\"return\",\n\t\"super\",\n\t\"switch\",\n\t\"this\",\n\t\"throw\",\n\t\"try\",\n\t\"typeof\",\n\t\"var\",\n\t\"void\",\n\t\"while\",\n\t\"with\",\n\t\"yield\",\n\t\"implements\",\n\t\"package\",\n\t\"protected\",\n\t\"static\",\n\t\"interface\",\n\t\"private\",\n\t\"public\",\n\t\"null\",\n\t\"true\",\n\t\"false\",\n\t\"undefined\",\n];\n\nconst keywordsRegex = new RegExp(`^(${keywords.join(\"|\")})\\\\b`);\n\nexport default function parse (text) {\n\tconst ctrl = new ParseCtrl(text);\n\tconst parse = {\n\t\tstring () {\n\t\t\tif (ctrl.node.type === \"string\") {\n\t\t\t\tconst node = ctrl.node;\n\t\t\t\tif (ctrl.match(ctrl.node.data.quote)) {\n\t\t\t\t\tconst matchEscapes = ctrl.precedes(/(\\\\+)$/);\n\t\t\t\t\tif (\n\t\t\t\t\t\t!matchEscapes ||\n\t\t\t\t\t\t(matchEscapes && matchEscapes[1].length % 2 === 0)\n\t\t\t\t\t) {\n\t\t\t\t\t\tctrl.go().end();\n\t\t\t\t\t\tnode.data.val = node.text;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tconst matchQuote = ctrl.match(/^([\"'`])/);\n\t\t\t\tif (matchQuote) {\n\t\t\t\t\tctrl.start(\"string\", {data: {quote: matchQuote[1]}});\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tcomment () {\n\t\t\tconst match = ctrl.match(/^(\\/\\/.*?)(?:$|\\Z)/m) || ctrl.match(/^(\\/\\*[\\s\\S]*?\\*\\/)/);\n\t\t\tif (match) {\n\t\t\t\tconsole.log(\"comment\", match[1]);\n\t\t\t\tctrl.go(match[1].length).add(\"comment\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tkeyword () {\n\t\t\tconst match = ctrl.match(keywordsRegex);\n\t\t\tif (match) {\n\t\t\t\tctrl\n\t\t\t\t\t.go(match[1].length)\n\t\t\t\t\t.add(\"keyword\", {data: {val: match[1]}});\n\t\t\t}\n\t\t},\n\t\tbrackets () {\n\t\t\tif (ctrl.node.type === \"brackets\" && ctrl.match(ctrl.node.data.close)) {\n\t\t\t\tctrl.go().end();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\tconst match = ctrl.match(/^([\\(\\[\\{])/);\n\t\t\tif (match) {\n\t\t\t\tctrl.start(\"brackets\", {data: {open: match[1], close: {\"{\": \"}\", \"(\": \")\", \"[\": \"]\"}[match[1]]}});\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tdot () {\n\t\t\tconst match = ctrl.match(/^(\\.+)/);\n\t\t\tif (match && match[1].length === 1) {\n\t\t\t\tctrl.go().add(\".\", {data: {val: \".\"}});\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tcomma () {\n\t\t\tif (ctrl.match(\",\")) {\n\t\t\t\tctrl.go().add(\",\", {data: {val: \",\"}});\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tcolon () {\n\t\t\tif (ctrl.match(\":\")) {\n\t\t\t\tctrl.go().add(\":\", {data: {val: \":\"}});\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tsemicolon () {\n\t\t\tif (ctrl.match(\";\")) {\n\t\t\t\tctrl.go().add(\";\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tarrow () {\n\t\t\tif (ctrl.match(\"=>\")) {\n\t\t\t\tctrl.go(2).add(\"=>\", {data: {val: \"=>\"}});\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tnumber () {\n\t\t\tconst match = ctrl.match(/^(\\d+?\\.?\\d*)/);\n\t\t\tif (match) {\n\t\t\t\tctrl.go(match[1].length).add(\"number\", {data: {val: match[1]}});\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tliteral () {\n\t\t\t// a  // когда в левой части выражения и без цепочек\n\t\t\tconst match = ctrl.match(/^([a-z][a-z0-9]*)/i);\n\t\t\tif (match) {\n\t\t\t\tctrl\n\t\t\t\t\t.go(match[1].length)\n\t\t\t\t\t.add(\"literal\", {data: {val: match[1]}});\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\toperation () {\n\t\t\tconst match = ctrl.match(/^([^\\s,;\\])}a-z]+)/i);\n\t\t\tif (match) {\n\t\t\t\tctrl\n\t\t\t\t\t.go(match[1].length)\n\t\t\t\t\t.add(\"operation\", {data: {val: match[1]}});\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tlinebreak () {\n\t\t\tif (ctrl.match(/^\\n/)) {\n\t\t\t\tctrl.go().add(\"linebreak\");\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t};\n\n\twhile (!ctrl.isEnd()) {\n\t\tswitch (ctrl.node.type) {\n\t\t\tcase \"string\": {\n\t\t\t\tparse.string();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"comment\": {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t[\n\t\t\t\t\tparse.comment,\n\t\t\t\t\tparse.string,\n\t\t\t\t\tparse.linebreak,\n\t\t\t\t\tparse.semicolon,\n\t\t\t\t\tparse.number,\n\t\t\t\t\tparse.keyword,\n\t\t\t\t\tparse.brackets,\n\t\t\t\t\tparse.colon,\n\t\t\t\t\tparse.comma,\n\t\t\t\t\tparse.dot,\n\t\t\t\t\tparse.arrow,\n\t\t\t\t\tparse.literal,\n\t\t\t\t\tparse.operation,\n\t\t\t\t].some(p => p());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tctrl.next();\n\t}\n\treturn ctrl;\n}\n","const isInvalid = (value) => value == null || (typeof value !== \"object\" && typeof value !== \"function\");\n\nconst spitPath = (path) => path.split(\".\");\n\nexport default class Scope {\n\tconstructor (stack) {\n\t\tthis.stack = [].concat(stack);\n\t\tthis.get = this.get.bind(this);\n\t\tthis.new = this.new.bind(this);\n\t}\n\tnew (scope) {\n\t\treturn new Scope([...this.stack, scope || {}]);\n\t}\n\tget (chain, callArgs, isLocal, getter, setter) {\n\t\tlet chainIdx = 0;\n\t\tlet value;\n\t\tif (isLocal) {\n\t\t\tvalue = getter;\n\t\t}\n\t\telse {\n\t\t\ttry {\n\t\t\t\tvalue = getter();\n\t\t\t\tif (!callArgs && typeof setter === \"function\" && chain.length > 1 && isInvalid(value)) {\n\t\t\t\t\tvalue = {};\n\t\t\t\t\tsetter(value);\n\t\t\t\t}\n\t\t\t\tchainIdx = 1;\n\t\t\t}\n\t\t\tcatch (error) {/**/}\n\t\t}\n\n\t\tlet context = value;\n\t\tif (chainIdx === 0) { // find key in scope stack\n\t\t\tlet i = this.stack.length - 1;\n\t\t\tconst key = chain[0];\n\t\t\twhile (i >= 0) {\n\t\t\t\tif (key in this.stack[i] || i === 0) {\n\t\t\t\t\tcontext = this.stack[i];\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\ti--;\n\t\t\t}\n\t\t}\n\n\t\twhile (chainIdx < chain.length) {\n\t\t\tconst key = chain[chainIdx];\n\t\t\tvalue = context[key];\n\t\t\tif (setter) {\n\t\t\t\tif (chainIdx === chain.length - 1) {\n\t\t\t\t\treturn {\n\t\t\t\t\t\tget val () {\n\t\t\t\t\t\t\treturn context[key];\n\t\t\t\t\t\t},\n\t\t\t\t\t\tset val (value) {\n\t\t\t\t\t\t\tcontext[key] = value;\n\t\t\t\t\t\t},\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\tif (isInvalid(value)) {\n\t\t\t\t\tvalue = {};\n\t\t\t\t\tcontext[key] = value;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (isInvalid(value) && chainIdx < chain.length - 1) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tcontext = value;\n\t\t\tchainIdx++;\n\t\t}\n\n\t\tif (chainIdx === chain.length && callArgs && typeof value === \"function\") {\n\t\t\treturn value.apply(context, callArgs);\n\t\t}\n\t\treturn value;\n\t}\n}\n","\nimport parseExpression from \"./parse-expression\";\nimport formatExpression from \"./format-expression\";\n\nexport default format;\n\n\nconst fns = {\n\tlist (args, content) {\n\t\targs = args.split(\" \");\n\t\treturn `...((call) => ${formatExpression(parseExpression(args[0]).root)})((${args[2]}) => ${content})`;\n\t},\n};\n\n\nconst formatNode = (node, content) => {\n\tif (node.type === \"tag\") {\n\t\tif (content && content.length) {\n\t\t\treturn `h(\"${node.data.tagName}\", {}, [${content.join(\", \")}])`;\n\t\t}\n\t\telse {\n\t\t\treturn `h(\"${node.data.tagName}\", {})`;\n\t\t}\n\t}\n\telse if (node.type === \"expression\") {\n\t\tif (node.data.control === \"#\") {\n\t\t\treturn `${fns[node.data.fn](node.data.args, content)}`;\n\t\t}\n\t\telse {\n\t\t\treturn `h(null, null, ${formatExpression(parseExpression(node.data.expression).root)})`;\n\t\t}\n\t}\n\treturn `h(null, null, \"${(node.data.content || \"\").replace(/\\s+/igm, \" \")}\")`;\n};\n\n\nfunction makeHierarchy (list) {\n\tlet cnt = 0;\n\tconst cntCtrl = 0;\n\tlet openNode;\n\tlet openNodeIdx;\n\tconst nodes = [];\n\tlet idx = 0;\n\tconst result = [];\n\twhile (idx < list.length) {\n\t\tconst node = list[idx];\n\t\tconst {data, type} = node;\n\t\tif (node.type === \"tag\" || (node.type === \"expression\" && data.control)) {\n\t\t\tif (openNode) {\n\t\t\t\tif (openNode.type === \"tag\") {\n\t\t\t\t\tif (type === \"tag\" && data.open && data.tagName === openNode.data.tagName) {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\tif (type === \"tag\" && data.close && data.tagName === openNode.data.tagName) {\n\t\t\t\t\t\tcnt--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (type === \"expression\") {\n\t\t\t\t\tif (data.control === \"#\") {\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (data.control === \"/\") {\n\t\t\t\t\t\tcnt--;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cnt === 0) {\n\t\t\t\t\tresult.push(formatNode(openNode, makeHierarchy(list.splice(openNodeIdx + 1, idx - openNodeIdx - 2))));\n\t\t\t\t\topenNode = null;\n\t\t\t\t\tidx = openNodeIdx;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tif (type === \"tag\") {\n\t\t\t\t\tif (data.open) {\n\t\t\t\t\t\topenNode = node;\n\t\t\t\t\t\topenNodeIdx = idx;\n\t\t\t\t\t\tcnt++;\n\t\t\t\t\t}\n\t\t\t\t\telse if (data.selfClosing) {\n\t\t\t\t\t\tresult.push(formatNode(node));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (type === \"expression\" && data.control === \"#\") {\n\t\t\t\t\topenNode = node;\n\t\t\t\t\topenNodeIdx = idx;\n\t\t\t\t\tcnt++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\telse if (cnt === 0) {\n\t\t\tresult.push(formatNode(node));\n\t\t}\n\t\tidx++;\n\t}\n\treturn result;\n}\n\nfunction format (list, type = \"root\") {\n\treturn makeHierarchy(list);\n}\n","import ParseCtrl from \"./parse-ctrl.js\";\n\nconst startExp = \"{{\";\nconst endExp = \"}}\";\n\nexport default function parse (text) {\n\tconst ctrl = new ParseCtrl(text);\n\tconst parse = {\n\t\tstartTag () {\n\t\t\tif (ctrl.match(\"<\")) {\n\t\t\t\tconst match = ctrl.match(/^<([a-z](-?[a-z])*)/i);\n\t\t\t\tif (match) {\n\t\t\t\t\tconst tagName = match[1];\n\t\t\t\t\tctrl.start(\"tag\", {data: {tagName, open: true}});\n\t\t\t\t\tctrl.go(tagName.length + 1);\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tconst matchClose = ctrl.match(/^<\\/([a-z](-?[a-z])*)>/i);\n\t\t\t\t\tif (matchClose) {\n\t\t\t\t\t\tconst tagName = matchClose[1];\n\t\t\t\t\t\tctrl\n\t\t\t\t\t\t\t.go(matchClose[0].length)\n\t\t\t\t\t\t\t.add(\"tag\", {data: {tagName, close: true}});\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\tstartComment () {\n\t\t\tif (ctrl.match(\"<!--\")) {\n\t\t\t\tctrl.start(\"comment\");\n\t\t\t\tctrl.go(4);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tendComment () {\n\t\t\tif (ctrl.match(\"-->\")) {\n\t\t\t\tctrl.go(3).end();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tendTag () {\n\t\t\tif (ctrl.match(\"/>\")) {\n\t\t\t\tctrl.go(2).end({data: {selfClosing: true}});\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse if (ctrl.match(\">\")) {\n\t\t\t\tctrl.go().end();\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tstartAttr () {\n\t\t\tconst match = ctrl.match(/^([@&$:][a-z]+)?:?([a-z-]+)?(?:=([\"']))?/i);\n\t\t\tif (match && match[0]) {\n\t\t\t\tlet [full, prefix, attr, quote] = match;\n\t\t\t\tconst prefixType = prefix ? prefix[0] : null;\n\t\t\t\tif (prefix) {\n\t\t\t\t\tprefix = prefix.substr(1);\n\t\t\t\t}\n\t\t\t\tif (quote) {\n\t\t\t\t\tctrl.start(\"attr\", {data: {attr, prefix, prefixType, quote}});\n\t\t\t\t\tctrl.go(full.length);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tctrl\n\t\t\t\t\t\t.go(full.length)\n\t\t\t\t\t\t.add(\"attr\", {data: {attr, prefix, prefixType}});\n\t\t\t\t}\n\t\t\t\treturn true;\n\t\t\t}\n\t\t},\n\t\tattr () {\n\t\t\tconst matchExpr = ctrl.match(startExp);\n\t\t\tif ([\"&\", \"$\", \"=\", \":\"].includes(ctrl.node.data.prefixType)) {\n\t\t\t\tctrl.startCopy();\n\t\t\t\tlet m;\n\t\t\t\tconst matcher = `${ctrl.node.data.quote}`;\n\t\t\t\twhile (!m && !ctrl.isEnd()) {\n\t\t\t\t\tm = ctrl.match(matcher);\n\t\t\t\t\t!m && ctrl.go();\n\t\t\t\t}\n\t\t\t\tif (m) {\n\t\t\t\t\tconst expression = ctrl.endCopy();\n\t\t\t\t\t// if (ctrl.node.data.prefixType === \"&\") {\n\t\t\t\t\t// \texpression = `()=>(${expression})`;\n\t\t\t\t\t// }\n\t\t\t\t\tctrl.go(matcher.length).end({data: {expression}});\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// parse string\n\t\t\t\tconst stringRegex = /^((\"(?:[^\"\\\\]|\\\\.)*\")|('(?:[^'\\\\]|\\\\.)*'))/;\n\t\t\t\tconst match = ctrl.go(-1).match(stringRegex);\n\t\t\t\tif (match) {\n\t\t\t\t\tctrl.node.value = match[0];\n\t\t\t\t\tctrl.go(match[0].length).end();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\ttext () {\n\t\t\tconst lastNode = ctrl.root.children[ctrl.root.children.length - 1];\n\t\t\tif (lastNode && lastNode.type === \"text\") {\n\t\t\t\tlastNode.end = ctrl.idx;\n\t\t\t\tlastNode.data.content += ctrl.get(1);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tctrl.go(1).add(\"text\", {data: {content: ctrl.get(1)}});\n\t\t\t}\n\t\t},\n\t\texpression () {\n\t\t\tconst match = ctrl.match(\n\t\t\t\tnew RegExp(`^${startExp}(#|/)?(.*?)${endExp}`)\n\t\t\t);\n\t\t\tif (match) {\n\t\t\t\tconst {\"0\": full, \"1\": control, \"2\": expression} = match;\n\t\t\t\tlet fn;\n\t\t\t\tlet args;\n\t\t\t\tif (control === \"#\") {\n\t\t\t\t\tconst match = expression.match(\n\t\t\t\t\t\t/^([a-z]+(?:-[a-z]*)*)\\s?(.*)/i\n\t\t\t\t\t);\n\t\t\t\t\tfn = match[1];\n\t\t\t\t\targs = match[2];\n\t\t\t\t}\n\t\t\t\tctrl.go(full.length).add(\"expression\", {\n\t\t\t\t\tdata: {expression, control, fn, args},\n\t\t\t\t});\n\t\t\t}\n\t\t},\n\t};\n\n\twhile (!ctrl.isEnd()) {\n\t\tswitch (ctrl.node.type) {\n\t\t\tcase \"tag\": {\n\t\t\t\tif (ctrl.node.data.open) {\n\t\t\t\t\t[parse.endTag, parse.startAttr].some(p => p());\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tparse.endTag();\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"attr\": {\n\t\t\t\tparse.attr();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tcase \"comment\": {\n\t\t\t\tparse.endComment();\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tdefault: {\n\t\t\t\t[\n\t\t\t\t\tparse.startTag,\n\t\t\t\t\tparse.startComment,\n\t\t\t\t\tparse.expression,\n\t\t\t\t\tparse.text,\n\t\t\t\t].some(p => p());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tctrl.next();\n\t}\n\treturn ctrl;\n}\n","import parseExpression from \"./parse-expression\";\nimport parseTpl from \"./parse-tpl\";\nimport formatExpression from \"./format-expression\";\nimport formatTpl from \"./format-tpl\";\nimport Scope from \"./scope\";\n\nexport default {\n\tparseExpression,\n\tparseTpl,\n\tformatExpression,\n\tformatTpl,\n\tScope,\n};\n","module.exports = require(\"./index.js\").default;\n"],"sourceRoot":""}